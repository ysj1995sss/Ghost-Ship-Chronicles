<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ghost Ship Chronicles</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,600;0,700;1,400&family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #0a0a0a;
            color: #d4d4d8;
            font-family: 'Crimson Text', serif;
            overflow: hidden; /* App-like feel */
        }

        /* CRT / Fog Overlay Effect */
        .atmosphere {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(circle at center, transparent 50%, #000000 100%);
            z-index: 50;
            opacity: 0.8;
        }

        .fog {
            position: fixed;
            top: 0;
            left: 0;
            width: 200%;
            height: 100%;
            background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0MDAiIGhlaWdodD0iNDAwIj48ZmlsdGVyIGlkPSJnoiPjxmZVR1cmJ1bGVuY2UgdHlwZT0iZnJhY3RhbE5vaXNlIiBiYXNlRnJlcXVlbmN5PSIwLjY1IiBudW1PY3RhdmVzPSIzIiBzdGl0Y2hUaWxlcz0ic3RpdGNoIi8+PC9maWx0ZXI+PHJlY3Qgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgZmlsdGVyPSJ1cmwoI2YpIiBvcGFjaXR5PSIwLjAzIi8+PC9zdmc+');
            z-index: 40;
            animation: drift 60s linear infinite;
            opacity: 0.3;
        }

        @keyframes drift {
            from { transform: translateX(0); }
            to { transform: translateX(-50%); }
        }

        .journal-container {
            max-width: 800px;
            height: 90vh;
            margin: 5vh auto;
            background: #121212;
            border: 1px solid #333;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 10;
            border-radius: 4px;
        }

        .story-scroll {
            flex-grow: 1;
            overflow-y: auto;
            padding: 2rem;
            padding-bottom: 100px; /* Space for controls */
            scrollbar-width: thin;
            scrollbar-color: #333 #121212;
        }

        .story-scroll::-webkit-scrollbar {
            width: 8px;
        }
        .story-scroll::-webkit-scrollbar-thumb {
            background: #333;
        }

        .story-entry {
            margin-bottom: 2rem;
            opacity: 0;
            animation: fadeIn 1s forwards;
            font-size: 1.2rem;
            line-height: 1.8;
            border-left: 2px solid #222;
            padding-left: 1rem;
        }

        .story-entry.user-action {
            border-left: 2px solid #4b5563;
            color: #9ca3af;
            font-style: italic;
            font-size: 1rem;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        .controls-area {
            background: linear-gradient(to top, #121212 90%, transparent);
            padding: 2rem;
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        .choice-btn {
            width: 100%;
            max-width: 600px;
            background: transparent;
            border: 1px solid #444;
            color: #d4d4d8;
            padding: 1rem;
            font-family: 'Cinzel', serif;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .choice-btn:hover:not(:disabled) {
            border-color: #d4d4d8;
            background: rgba(255,255,255,0.05);
            text-shadow: 0 0 8px rgba(255,255,255,0.5);
        }

        .choice-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #222;
        }

        .typing-indicator {
            display: flex;
            gap: 0.5rem;
            padding: 1rem;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .dot {
            width: 6px;
            height: 6px;
            background: #666;
            border-radius: 50%;
            animation: bounce 1.4s infinite ease-in-out both;
        }

        .dot:nth-child(1) { animation-delay: -0.32s; }
        .dot:nth-child(2) { animation-delay: -0.16s; }

        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }

        h1 {
            font-family: 'Cinzel', serif;
            text-align: center;
            margin-top: 1rem;
            color: #52525b;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            font-size: 1.5rem;
        }

        /* Typewriter cursor effect */
        .typewriter::after {
            content: '|';
            animation: blink 1s infinite;
        }
        @keyframes blink { 50% { opacity: 0; } }

        .dead-text { color: #ef4444; }
        .win-text { color: #fbbf24; }
        
    </style>
</head>
<body>

    <div class="atmosphere"></div>
    <div class="fog"></div>

    <h1>Ghost Ship Chronicles</h1>

    <div class="journal-container">
        <div id="storyLog" class="story-scroll">
            <!-- Story content goes here -->
        </div>

        <div class="controls-area">
            <div id="loader" class="typing-indicator">
                <div class="dot"></div><div class="dot"></div><div class="dot"></div>
            </div>
            <div id="choices" class="w-full flex flex-col items-center gap-3">
                <!-- Buttons go here -->
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const apiKey = ""; // Provided by execution environment
        const MODEL_NAME = "gemini-2.5-flash-preview-09-2025";

        // --- STATE ---
        let conversationHistory = [];
        const systemPrompt = `
You are the Dungeon Master for a text adventure game set on a haunted 18th-century pirate ship called 'The Black Banshee'.
Your goal is to provide atmospheric, gritty, and slightly Lovecraftian descriptions.

RULES:
1. Response must be valid JSON.
2. Structure: { "narrative": "string", "choices": ["string", "string"], "status": "playing" | "game_over" | "victory" }
3. "narrative": The story segment. Keep it under 80 words. Be descriptive but concise.
4. "choices": Exactly 2 distinct actions the player can take.
5. "status": "playing" for normal gameplay, "game_over" if the player dies, "victory" if they escape or solve the mystery.
6. If status is not "playing", "choices" should be ["Restart"].
7. Do not include markdown formatting in the JSON keys.

STARTING CONTEXT:
The player wakes up in the Captain's Cabin. It is dark, smells of rot, and green moonlight filters through the windows.
`;

        // --- DOM ELEMENTS ---
        const storyLog = document.getElementById('storyLog');
        const choicesDiv = document.getElementById('choices');
        const loader = document.getElementById('loader');

        // --- AUDIO ---
        const AudioSys = {
            ctx: null,
            init: function() {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
            },
            playType: function() {
                if (!this.ctx) return;
                // Very subtle click
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.setValueAtTime(800 + Math.random() * 200, t);
                gain.gain.setValueAtTime(0.02, t);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(t + 0.05);
            },
            playAmbience: function(type) {
                // Simple placeholder for expanding later
                if (!this.ctx) return;
            }
        };

        // --- API INTERACTION ---
        async function generateStory(userAction) {
            // Show loader, disable UI
            loader.style.opacity = '1';
            choicesDiv.innerHTML = '';

            // Update history
            if (userAction) {
                conversationHistory.push({ role: "user", parts: [{ text: userAction }] });
                addEntry(userAction, 'user-action');
            }

            // Construct payload
            const contents = [
                { role: "user", parts: [{ text: "Generate the next scene." }] }, // Trigger
                ...conversationHistory // Append context
            ];

            // Safety: Limit history size to avoid token limits (keep last 10 turns)
            if (contents.length > 20) {
                contents.splice(1, contents.length - 21); 
            }

            try {
                const response = await fetchWithRetry(contents);
                const data = parseResponse(response);
                
                // Update history with AI response
                conversationHistory.push({ role: "model", parts: [{ text: JSON.stringify(data) }] });
                
                renderScene(data);

            } catch (e) {
                console.error(e);
                addEntry("The mists obscure your vision... (Connection Error. Please restart.)", "dead-text");
                renderButtons(["Restart"], "game_over");
            } finally {
                loader.style.opacity = '0';
            }
        }

        async function fetchWithRetry(contents, retries = 3) {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${apiKey}`;
            const payload = {
                contents: contents,
                systemInstruction: { parts: [{ text: systemPrompt }] },
                generationConfig: {
                    responseMimeType: "application/json"
                }
            };

            for (let i = 0; i < retries; i++) {
                try {
                    const res = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    if (!res.ok) throw new Error(`API Error: ${res.status}`);
                    const data = await res.json();
                    return data;
                } catch (err) {
                    if (i === retries - 1) throw err;
                    await new Promise(r => setTimeout(r, 1000 * Math.pow(2, i)));
                }
            }
        }

        function parseResponse(apiResponse) {
            try {
                const text = apiResponse.candidates[0].content.parts[0].text;
                return JSON.parse(text);
            } catch (e) {
                // Fallback if JSON is malformed
                return {
                    narrative: "A chaotic force disrupts reality. You cannot proceed.",
                    choices: ["Restart"],
                    status: "game_over"
                };
            }
        }

        // --- UI RENDERING ---

        function addEntry(text, className = '') {
            const div = document.createElement('div');
            div.className = `story-entry ${className}`;
            storyLog.appendChild(div);
            
            // Typewriter effect for narrative
            if (!className.includes('user-action')) {
                typeText(div, text);
            } else {
                div.innerText = `> ${text}`;
                scrollToBottom();
            }
        }

        function typeText(element, text) {
            element.classList.add('typewriter');
            let i = 0;
            element.innerText = '';
            
            const interval = setInterval(() => {
                element.innerText += text.charAt(i);
                if (i % 3 === 0) AudioSys.playType(); // Sound every few chars
                i++;
                scrollToBottom();

                if (i >= text.length) {
                    clearInterval(interval);
                    element.classList.remove('typewriter');
                }
            }, 20); // Speed
        }

        function renderScene(data) {
            // Add narrative
            let className = '';
            if (data.status === 'game_over') className = 'dead-text';
            if (data.status === 'victory') className = 'win-text';
            
            addEntry(data.narrative, className);

            // Wait for typing to (mostly) finish before showing buttons? 
            // Simplified: just show buttons immediately, user can read while they render
            setTimeout(() => {
                renderButtons(data.choices, data.status);
            }, data.narrative.length * 20 + 500);
        }

        function renderButtons(choices, status) {
            choicesDiv.innerHTML = '';
            
            choices.forEach(choiceText => {
                const btn = document.createElement('button');
                btn.className = 'choice-btn';
                btn.innerText = choiceText;
                
                btn.onclick = () => {
                    if (status !== 'playing') {
                        // Restart logic
                        location.reload();
                    } else {
                        generateStory(choiceText);
                    }
                };
                
                // Slight stagger animation
                btn.style.animation = 'fadeIn 0.5s forwards';
                choicesDiv.appendChild(btn);
            });
            scrollToBottom();
        }

        function scrollToBottom() {
            storyLog.scrollTop = storyLog.scrollHeight;
        }

        // --- INITIALIZATION ---
        
        // Hardcoded start to prevent initial load time and save 1 API call
        const initialScene = {
            narrative: "You jolt awake. The air is cold and heavy with the smell of brine and ancient rot. You are in the Captain's quarters of 'The Black Banshee', yet the Captain is nowhere to be seen. A spectral green light filters through the cracked stern window, illuminating dust motes dancing in the silence. The ship groans beneath you.",
            choices: ["Search the Captain's desk", "Try the heavy oak door"],
            status: "playing"
        };

        window.onload = () => {
            AudioSys.init();
            
            // Seed history with the initial state so the AI knows where we started
            conversationHistory.push({ 
                role: "model", 
                parts: [{ text: JSON.stringify(initialScene) }] 
            });
            
            renderScene(initialScene);
        };

    </script>
</body>
</html>
